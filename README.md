# Sharpening my programming skills

<img align="right" alt="mbtoolbox" src="keep_tools_sharp.png" />

This is a collection of small (< 1h) Python challenges
to keep your Python skills sharp.

## Challenges

The challenges are explained in detail
in the comments of the corresponding Python files.

### Arrays

- [x] **[zero_matrix.py](challenges/array/zero_matrix.py)**: Zero entire column and row in 2D matrix if element is `0`.
- [x] **[merge_overlapping_intervals.py](challenges/array/merge_overlapping_intervals.py)**: Merge overlapping intervals in array together.
- [x] **[rotate_matrix.py](challenges/array/rotate_matrix.py)**: Rotate 2D matrix 90 degrees.
- [x] **[spiral_order.py](challenges/array/spiral_order.py)**: Return a 2D matrix in spiral order.
- [x] **[temp_tracker.py](challenges/array/temp_tracker.py)**: Temperature tracker to calculate mean, mode, min, max of temperature events.
- [x] **[max_consecutive_gap.py](challenges/array/max_consecutive_gap.py)**: Find max consecutive gap of sorted form of unsorted numbers.
- [x] **[find_permutation.py](challenges/array/find_permutation.py)**: Find first permutation based on two conditions.
- [x] **[pascal_triangle.py](challenges/array/pascal_triangle.py)**: Generate the first n rows of the Pascal's triangle.
- [x] **[wave_array.py](challenges/array/wave_array.py)**: Sort array in a wave-like pattern.
- [x] **[sorted_array_intersection.py](challenges/array/sorted_array_intersection.py)**: Find elements that occur in both of the two sorted arrays.
- [x] **[rearrange_array.py](challenges/array/rearrange_array.py)**: Rearrange array so that the values become the indizes.
- [x] **[min_steps_infinite_grid.py](challenges/array/min_steps_infinite_grid.py)**: Cover given points in 2D grid in minimum steps.
- [ ] **[max_subarray.py](challenges/array/max_subarray.py)**: Calculate the max sum of a subarray.
- [ ] **[array_duplicate.py](challenges/array/array_duplicate.py)**: Find the first duplicate in an array of integers.


###Â Math

- [x] **[palindrome_integer.py](challenges/math/palindrome_integer.py)**: Check if integer is palindrome without converting it to text.
- [x] **[excel_column_number.py](challenges/math/excel_column_number.py)**: Return column number based on Excel encoded column title.
- [x] **[factorial_trailing_zeros.py](challenges/math/factorial_trailing_zeros.py)**: Count trailing zeros in factorial (`n!`).
- [x] **[greatest_common_divisor.py](challenges/math/greatest_common_divisor.py)**: Greatest common divisor of two numbers.
- [ ] **[two_egg_problem.py](challenges/math/two_egg_problem.py)**: Solve the [Two Egg Problem](http://datagenetics.com/blog/july22012/index.html)

### Strings

- [x] **[palindrome_string.py](challenges/string/palindrome_string.py)**: Check if sentence is a palindrome.
- [x] **[needle_haystack.py](challenges/string/needle_haystack.py)**: Find substring in a string (without fancy KMP or Boyer-Moore).
- [x] **[zigzag_string.py](challenges/string/zigzag_string.py)**: Print text in a zigzag pattern to the screen.
- [x] **[compare_version_numbers.py](challenges/string/compare_version_numbers.py)**: Compare version strings like v1.1 and v1.2.
- [x] **[longest_palindromic_substring.py](challenges/string/longest_palindromic_substring.py)**: Find longest palindrome substring.
- [x] **[roman_to_integer.py](challenges/string/roman_to_integer.py)**: Calculate integer from roman literals.
- [x] **[integer_to_roman.py](challenges/string/integer_to_roman.py)**: Create roman literal from integer.
- [x] **[length_last_word.py](challenges/string/length_last_word.py)**: Calculate length of last word in sentence.
- [x] **[longest_common_prefix.py](challenges/string/longest_common_prefix.py)**: Find longest common prefix in all strings.
- [x] **[reverse_string_inplace.py](challenges/string/reverse_string_inplace.py)**: Reverse string or array in place.
- [ ] **[string_multiplication.py](challenges/string/string_multiplication.py)**: Multiply two numbers represented as strings without big integer libraries.

### Bit Manipulation

- [x] **[bit_single_number.py](challenges/bit_manipulation/bit_single_number.py)**: Find single number in array of pairs.
- [x] **[power_of_2.py](challenges/bit_manipulation/power_of_2.py)**: Check if number is power of 2.

### Two Pointers

- [x] **[diffk.py](challenges/two_pointers/diffk.py)**: Find two values in sorted array with a difference of k.
- [x] **[container_most_water.py](challenges/two_pointers/container_most_water.py)**: Based  on vertical lines on a x-axis find the lines having the largest area.
- [ ] **[rectangle_intersection.py](challenges/two_pointers/rectangle_intersection.py)**: Find intersection of two rectangles.

### Binary Search

- [ ] **[binary_matrix_search.py](challenges/binary_search/binary_matrix_search.py)**: Test for existence of element in matrix using binary search.
- [ ] **[rotated_sorted_array_search.py](challenges/binary_search/rotated_sorted_array_search.py)**: A sorted array is rotated at one place :interrobang:.
- [x] **[sqrt.py](challenges/binary_search/sqrt.py)**: Calculate square root using binary search.
- [x] **[sorted_insert_position.py](challenges/binary_search/sorted_insert_position.py)**: Return found index of element or index where to insert it.
- [x] **[search_range.py](challenges/binary_search/search_range.py)**: Find range (start and end index) of a value in a sorted list.
- [x] **[binary_occurrence_search.py](challenges/binary_search/binary_occurrence_search.py)**: Count number of occurences of target value in sorted list.
- [x] **[power.py](challenges/binary_search/power.py)**: Implement `pow(x, n) % d`.

### Stack

- [ ] **[generate_parentheses.py](challenges/stack/generate_parentheses.py)**: Validate parentheses
- [ ] **[min_stack.py](challenges/stack/min_stack.py)**: Create a min stack preserving order of elements
- [ ] **[nearest_smallest_element.py](challenges/stack/nearest_smallest_element.py)**: Find nearest element in array
- [ ] **[simplify_directory_path.py](challenges/stack/simplify_directory_path.py)**: Simplify UNIX path
- [x] **[evaluate_expression.py](challenges/stack/evaluate_expression.py)**: Evaluate the value of an arithmetic expression in Reverse Polish Notation.


### Linked Lists

- [ ] **[interesection_linked_list.py](challenges/linked_list/interesection_linked_list.py)**: Find intersection of two linked lists
- [ ] **[swap_list_nodes_in_pairs.py](challenges/linked_list/swap_list_nodes_in_pairs.py)**: Swap nodes in linked list in pairs
- [ ] **[merge_sorted_lists.py](challenges/linked_list/merge_sorted_lists.py)**: Merge sorted linked lists
- [ ] **[partition_list.py](challenges/linked_list/partition_list.py)**: Partition linked list at pivot
- [ ] **[add_two_numbers_list.py](challenges/linked_list/add_two_numbers_list.py)**: Add to numbers as linked lists
- [ ] **[list_cycle.py](challenges/linked_list/list_cycle.py)**: Detect cycle in linked list
- [x] **[reverse_linked_list.py](challenges/linked_list/reverse_linked_list.py)**: Reverse linked list
- [x] **[reverse_linked_list_partial.py](challenges/linked_list/reverse_linked_list_partial.py)**: Reverse linked list but only up to a certain node count.

### Backtracking / Recursion

- [ ] **[modular_exponentiation.py](challenges/backtracking/modular_exponentiation.py)**: Modular exponentiation is a type of exponentiation performed over a modulus.
- [ ] **[permutations.py](challenges/backtracking/permutations.py)**: Generate all permutations in a list
- [ ] **[unique_permutations.py](challenges/backtracking/unique_permutations.py)**: Calculate unique permutations
- [ ] **[letter_phone.py](challenges/backtracking/letter_phone.py)**: Generate all possible digits on letter phone
- [ ] **[gen_parens.py](challenges/backtracking/gen_parens.py)**: Given n pairs of parentheses generate all combinations of well formed parentheses.
- [x] **[combinations.py](challenges/backtracking/combinations.py)**: Given n numbers generate all possible k combinations


### Hashing

- [ ] **[two_sum.py](challenges/hashing/two_sum.py)**: Given an array of integers, find two numbers such that they add up to a specific target number
- [ ] **[points_on_straight_line.py](challenges/hashing/points_on_straight_line.py)**: Given n points on 2D pane calculate max number of points on one straight line
- [ ] **[longest_substring_no_repeat.py](challenges/hashing/longest_substring_no_repeat.py)**: Calculate longest substring with unique characters

### Maps
- [x] **[anagrams.py](challenges/maps/anagrams.py)**: Given list of words return all words that are anagram of a given string.
- [ ] **[distinct_numbers_in_window.py](challenges/hashing/distinct_numbers_in_window.py)**: Given list of integers return the distinct numbers in window of size k.
- [x] **[majority_element.py](challenges/backtracking/majority_element.py)**: Given an array find the majority element

### Trees

- [x] **[identical_binary_tree.py](challenges/trees/identical_binary_tree.py)**: Compare two binary trees
- [x] **[inorder_traversal.py](challenges/trees/inorder_traversal.py)**: Binary tree inorder traversal
- [x] **[postorder_traversal.py](challenges/trees/postorder_traversal.py)**: Binary tree postorder traversal
- [x] **[preorder_traversal.py](challenges/trees/preorder_traversal.py)**: Binary tree preorder traversal
- [x] **[sorted_array_balanced_bst.py](challenges/trees/sorted_array_balanced_bst.py)**: Turn sorted array into balanced BST
- [x] **[invert_binary_tree.py](challenges/trees/invert_binary_tree.py)**: Invert binary tree
- [ ] **[path_sum.py](challenges/trees/path_sum.py)**: Compare path sum of leaf nodes
- [ ] **[flatten_binary_tree_linked_list.py](challenges/trees/flatten_binary_tree_linked_list.py)**: Flatten a binary tree into a right sided linked list
- [ ] **[balanced_binary_tree.py](challenges/trees/balanced_binary_tree.py)**: Check if a tree is balanced
- [ ] **[kth_smallest_tree_elem.py](challenges/trees/kth_smallest_tree_elem.py)**: Find the kth smallest element in a binary search tree
- [ ] **[valid_bst.py](challenges/trees/valid_bst.py)**: Check if binary tree is valid BST
- [ ] **[zigzag_level_bst_traversal.py](challenges/trees/zigzag_level_bst_traversal.py)**: Traverse BST in zig ziag level order
- [ ] **[max_tree_depth.py](challenges/trees/max_tree_depth.py)**: Longest path to leaf
- [ ] **[min_tree_depth.py](challenges/trees/min_tree_depth.py)**: Shortest path to leaf
- [ ] **[sum_root_leaf_numbers.py](challenges/trees/sum_root_leaf_numbers.py)**: Sum all root-to-leaf paths (node values are digits)
- [ ] **[merge_k_sorted_lists.py](challenges/trees/merge_k_sorted_lists.py)**: Merge k sorted lists into one
- [ ] **[count_inversions.py](challenges/trees/count_inversions.py)**: Count the number of inversions in an array.
- [ ] **[symmetric_binary_tree.py](challenges/trees/symmetric_binary_tree.py)**: Check if two binary trees are symmetric.
- [x] **[least_common_ancestor.py](challenges/trees/least_common_ancestor.py)**: Find the least common ancestor of two values in an unordered binary tree.
- [x] **[shortest_unique_prefix.py](challenges/trees/shortest_unique_prefix.py)**: Find the shortest unique prefix for each word in a set of words.
- [x] **[order_people_heights.py](challenges/trees/order_people_heights.py)**: Order people with unique heights by the constraint how many taller people are standing in front of them.

### Graphs
- [ ] **[level_order.py](challenges/graphs/level_order.py)**: Traverse tree in level order (BFS)
- [ ] **[black_shapes.py](challenges/graphs/black_shapes.py)**: Given a board of black and white fields find the number of black connected shapes

Greedy
------

- [x] **[trading_stock.py](challenges/greedy/trading_stock.py)**: Figure out max profit given the stock prices of yesterday.
- [x] **[bulbs.py](challenges/greedy/bulbs.py)**: Given wrong wired light bulbs find the min number of switches to press to turn on all the bulbs.
- [x] **[mice_holes.py](challenges/greedy/mice_holes.py)**: Given M mice and N holes on a straight line find min number of moves to assign all mice to the holes.
